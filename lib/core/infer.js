const inferredProperties = {
  array: [
    "additionalItems",
    "items",
    "maxItems",
    "minItems",
    "uniqueItems"
  ],
  integer: [
    "exclusiveMaximum",
    "exclusiveMinimum",
    "maximum",
    "minimum",
    "multipleOf"
  ],
  object: [
    "additionalProperties",
    "dependencies",
    "maxProperties",
    "minProperties",
    "patternProperties",
    "properties",
    "required"
  ],
  string: [
    "maxLength",
    "minLength",
    "pattern",
    "format"
  ]
};
inferredProperties.number = inferredProperties.integer;
const subschemaProperties = [
  "additionalItems",
  "items",
  "additionalProperties",
  "dependencies",
  "patternProperties",
  "properties"
];
function matchesType(obj, lastElementInPath, inferredTypeProperties) {
  return Object.keys(obj).filter((prop) => {
    const isSubschema = subschemaProperties.indexOf(lastElementInPath) > -1;
    const inferredPropertyFound = inferredTypeProperties.indexOf(prop) > -1;
    if (inferredPropertyFound && !isSubschema) {
      return true;
    }
    return false;
  }).length > 0;
}
function inferType(obj, schemaPath) {
  const keys = Object.keys(inferredProperties);
  for (let i = 0; i < keys.length; i += 1) {
    const typeName = keys[i];
    const lastElementInPath = schemaPath[schemaPath.length - 1];
    if (matchesType(obj, lastElementInPath, inferredProperties[typeName])) {
      return typeName;
    }
  }
}
var infer_default = inferType;
module.exports=infer_default;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9hbHZhcm8vV29ya3NwYWNlL2pzb24tc2NoZW1hLWZha2VyL3NyYy9saWIvY29yZS9pbmZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBpbmZlcnJlZFByb3BlcnRpZXMgPSB7XG4gIGFycmF5OiBbXG4gICAgJ2FkZGl0aW9uYWxJdGVtcycsXG4gICAgJ2l0ZW1zJyxcbiAgICAnbWF4SXRlbXMnLFxuICAgICdtaW5JdGVtcycsXG4gICAgJ3VuaXF1ZUl0ZW1zJyxcbiAgXSxcbiAgaW50ZWdlcjogW1xuICAgICdleGNsdXNpdmVNYXhpbXVtJyxcbiAgICAnZXhjbHVzaXZlTWluaW11bScsXG4gICAgJ21heGltdW0nLFxuICAgICdtaW5pbXVtJyxcbiAgICAnbXVsdGlwbGVPZicsXG4gIF0sXG4gIG9iamVjdDogW1xuICAgICdhZGRpdGlvbmFsUHJvcGVydGllcycsXG4gICAgJ2RlcGVuZGVuY2llcycsXG4gICAgJ21heFByb3BlcnRpZXMnLFxuICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICAncGF0dGVyblByb3BlcnRpZXMnLFxuICAgICdwcm9wZXJ0aWVzJyxcbiAgICAncmVxdWlyZWQnLFxuICBdLFxuICBzdHJpbmc6IFtcbiAgICAnbWF4TGVuZ3RoJyxcbiAgICAnbWluTGVuZ3RoJyxcbiAgICAncGF0dGVybicsXG4gICAgJ2Zvcm1hdCcsXG4gIF0sXG59O1xuXG5pbmZlcnJlZFByb3BlcnRpZXMubnVtYmVyID0gaW5mZXJyZWRQcm9wZXJ0aWVzLmludGVnZXI7XG5cbmNvbnN0IHN1YnNjaGVtYVByb3BlcnRpZXMgPSBbXG4gICdhZGRpdGlvbmFsSXRlbXMnLFxuICAnaXRlbXMnLFxuICAnYWRkaXRpb25hbFByb3BlcnRpZXMnLFxuICAnZGVwZW5kZW5jaWVzJyxcbiAgJ3BhdHRlcm5Qcm9wZXJ0aWVzJyxcbiAgJ3Byb3BlcnRpZXMnLFxuXTtcblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGFsbCBrZXlzIG9mIGBvYmpgIGFuZDpcbiAqIC0gY2hlY2tzIHdoZXRoZXIgdGhvc2Uga2V5cyBtYXRjaCBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gaW5mZXJyZWQgdHlwZVxuICogLSBtYWtlcyBzdXJlIHRoYXQgYG9iamAgaXMgbm90IGEgc3Vic2NoZW1hOyBfRG8gbm90IGF0dGVtcHQgdG8gaW5mZXIgcHJvcGVydGllcyBuYW1lZCBhcyBzdWJzY2hlbWEgY29udGFpbmVycy4gVGhlXG4gKiByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCBhbnkgcHJvcGVydHkgbmFtZSB3aXRoaW4gdGhvc2UgY29udGFpbmVycyB0aGF0IG1hdGNoZXMgb25lIG9mIHRoZSBwcm9wZXJ0aWVzIHVzZWQgZm9yXG4gKiBpbmZlcnJpbmcgbWlzc2luZyB0eXBlIHZhbHVlcyBjYXVzZXMgdGhlIGNvbnRhaW5lciBpdHNlbGYgdG8gZ2V0IHByb2Nlc3NlZCB3aGljaCBsZWFkcyB0byBpbnZhbGlkIG91dHB1dC4gKElzc3VlIDYyKV9cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1R5cGUob2JqLCBsYXN0RWxlbWVudEluUGF0aCwgaW5mZXJyZWRUeXBlUHJvcGVydGllcykge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5maWx0ZXIocHJvcCA9PiB7XG4gICAgY29uc3QgaXNTdWJzY2hlbWEgPSBzdWJzY2hlbWFQcm9wZXJ0aWVzLmluZGV4T2YobGFzdEVsZW1lbnRJblBhdGgpID4gLTE7XG4gICAgY29uc3QgaW5mZXJyZWRQcm9wZXJ0eUZvdW5kID0gaW5mZXJyZWRUeXBlUHJvcGVydGllcy5pbmRleE9mKHByb3ApID4gLTE7XG5cbiAgICBpZiAoaW5mZXJyZWRQcm9wZXJ0eUZvdW5kICYmICFpc1N1YnNjaGVtYSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9KS5sZW5ndGggPiAwO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGdpdmVuIGBvYmpgIHR5cGUgbWlnaHQgYmUgaW5mZXJyZWQuIFRoZSBtZWNoYW5pc20gaXRlcmF0ZXMgdGhyb3VnaCBhbGwgaW5mZXJyZWQgdHlwZXMgZGVmaW5pdGlvbnMsXG4gKiB0cmllcyB0byBtYXRjaCBhbGxvd2VkIHByb3BlcnRpZXMgd2l0aCBwcm9wZXJ0aWVzIG9mIGdpdmVuIGBvYmpgLiBSZXR1cm5zIHR5cGUgbmFtZSwgaWYgaW5mZXJyZWQsIG9yIG51bGwuXG4gKlxuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiBpbmZlclR5cGUob2JqLCBzY2hlbWFQYXRoKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhpbmZlcnJlZFByb3BlcnRpZXMpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHR5cGVOYW1lID0ga2V5c1tpXTtcbiAgICBjb25zdCBsYXN0RWxlbWVudEluUGF0aCA9IHNjaGVtYVBhdGhbc2NoZW1hUGF0aC5sZW5ndGggLSAxXTtcblxuICAgIGlmIChtYXRjaGVzVHlwZShvYmosIGxhc3RFbGVtZW50SW5QYXRoLCBpbmZlcnJlZFByb3BlcnRpZXNbdHlwZU5hbWVdKSkge1xuICAgICAgcmV0dXJuIHR5cGVOYW1lO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBpbmZlclR5cGU7XG4iXSwibWFwcGluZ3MiOiJBQUFBLE1BQU0scUJBQXFCO0FBQUEsRUFDekIsT0FBTztBQUFBLElBQ0w7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUE7QUFBQSxFQUVGLFNBQVM7QUFBQSxJQUNQO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBO0FBQUEsRUFFRixRQUFRO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBO0FBQUEsRUFFRixRQUFRO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBO0FBQUE7QUFJSixtQkFBbUIsU0FBUyxtQkFBbUI7QUFFL0MsTUFBTSxzQkFBc0I7QUFBQSxFQUMxQjtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUEsRUFDQTtBQUFBLEVBQ0E7QUFBQSxFQUNBO0FBQUE7QUFZRixxQkFBcUIsS0FBSyxtQkFBbUIsd0JBQXdCO0FBQ25FLFNBQU8sT0FBTyxLQUFLLEtBQUssT0FBTyxVQUFRO0FBQ3JDLFVBQU0sY0FBYyxvQkFBb0IsUUFBUSxxQkFBcUI7QUFDckUsVUFBTSx3QkFBd0IsdUJBQXVCLFFBQVEsUUFBUTtBQUVyRSxRQUFJLHlCQUF5QixDQUFDLGFBQWE7QUFDekMsYUFBTztBQUFBO0FBR1QsV0FBTztBQUFBLEtBQ04sU0FBUztBQUFBO0FBU2QsbUJBQW1CLEtBQUssWUFBWTtBQUNsQyxRQUFNLE9BQU8sT0FBTyxLQUFLO0FBRXpCLFdBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUssR0FBRztBQUN2QyxVQUFNLFdBQVcsS0FBSztBQUN0QixVQUFNLG9CQUFvQixXQUFXLFdBQVcsU0FBUztBQUV6RCxRQUFJLFlBQVksS0FBSyxtQkFBbUIsbUJBQW1CLFlBQVk7QUFDckUsYUFBTztBQUFBO0FBQUE7QUFBQTtBQUtiLElBQU8sZ0JBQVE7IiwibmFtZXMiOltdfQ==
